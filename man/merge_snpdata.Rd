% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SNPData-methods.R
\name{merge_snpdata}
\alias{merge_snpdata}
\title{Merge two SNPData objects}
\usage{
merge_snpdata(
  x,
  y,
  snp_join = c("union", "intersect", "left", "right"),
  cell_join = c("union", "intersect", "left", "right")
)
}
\arguments{
\item{x}{A SNPData object}

\item{y}{A SNPData object to merge with x}

\item{snp_join}{Join type for SNPs (rows). One of:
\describe{
  \item{\code{"union"}}{Keep all SNPs from both objects (default)}
  \item{\code{"intersect"}}{Keep only SNPs present in both objects}
  \item{\code{"left"}}{Keep all SNPs from x, add y data where available}
  \item{\code{"right"}}{Keep all SNPs from y, add x data where available}
}}

\item{cell_join}{Join type for cells (columns). One of:
\describe{
  \item{\code{"union"}}{Keep all cells from both objects (default)}
  \item{\code{"intersect"}}{Keep only cells present in both objects}
  \item{\code{"left"}}{Keep all cells from x, add y data where available}
  \item{\code{"right"}}{Keep all cells from y, add x data where available}
}}
}
\value{
A new SNPData object containing the merged data
}
\description{
Combines two SNPData objects with flexible join strategies for SNPs and cells.
Overlapping entries are summed; unique entries are retained based on join type.
}
\details{
This function provides independent control over which SNPs (rows) and cells
(columns) to retain when merging two SNPData objects. For positions present
in both objects, counts are summed element-wise. For positions present in
only one object (but retained by the join strategy), counts are kept with
zero-filling for the missing dimension.

**Cell Merging Strategy:**
When both SNPData objects contain a \code{barcode} column in their
\code{barcode_info}, cells are matched and merged by their cell barcodes
rather than by \code{cell_id}. This allows proper merging of data from the
same physical cells across datasets, even if they have different internal
\code{cell_id} values. For cells with the same barcode, counts are summed.
If the \code{barcode} column is absent from either object, the function falls
back to merging by \code{cell_id}.

Metadata is merged using the corresponding dplyr join function. For overlapping
SNPs or cells with conflicting metadata, values from x take priority. Auto-
computed columns (coverage, non_zero_samples, library_size, non_zero_snps)
are recalculated for the merged object.

The independent join parameters enable fine-grained control:
\itemize{
  \item \code{snp_join="union", cell_join="union"}: Maximum data retention
  \item \code{snp_join="intersect", cell_join="intersect"}: Strict QC, only validated entries
  \item \code{snp_join="union", cell_join="intersect"}: Track more SNPs in same cells
  \item \code{snp_join="intersect", cell_join="union"}: Track consensus SNPs across more cells
  \item \code{snp_join="left", cell_join="left"}: Augment primary dataset
}
}
\examples{
\dontrun{
# Technical replicates - sum depth for validated entries only
rep1 <- import_cellsnp("replicate1/")
rep2 <- import_cellsnp("replicate2/")
combined <- merge_snpdata(rep1, rep2,
                         snp_join = "intersect",
                         cell_join = "intersect")

# Batch integration - all cells, consensus SNPs only
batch1 <- import_cellsnp("donor1/")
batch2 <- import_cellsnp("donor2/")
integrated <- merge_snpdata(batch1, batch2,
                            snp_join = "intersect",
                            cell_join = "union")

# SNP panel expansion - all SNPs, validated cells only
common <- import_cellsnp("common_vars/")
rare <- import_cellsnp("rare_vars/")
expanded <- merge_snpdata(common, rare,
                         snp_join = "union",
                         cell_join = "intersect")

# Default: maximum data retention
dataset1 <- import_cellsnp("cohort_A/")
dataset2 <- import_cellsnp("cohort_B/")
combined <- merge_snpdata(dataset1, dataset2)
}

}
